# Карапетян Артём Гарегинович, БПИ228, @kg_artem в телеграме для любых вопросов
**Вариант 5.** Разработать программу, вычисляющую с помощью степенного ряда с точностью не хуже 0,05% значение функции arcsin (x) для заданного параметра x.

Заранее прошу использовать ассемблирование во всей директории и поиск main при наличии (это настройки rars самого).

[Целевая программа](idz2/main.s)

[Библиотека макросов](idz2/macrolib.s)

[Тестовая программа на Python3](idz2/main.py)

Программа на Python не открывает все директории сразу, поэтому [тестовая программа на RISC-V для проверочной программы на Python](idz2/main_for_python.s) содержит в себе main.s и helper.s (ни одного дополнительного изменения там нету).

[Тестовая программа на RISC-V](idz2/tester_program.s)

[Отдельный файл для ввода-вывода (на 10 баллов)](idz2/helper.s)

**Как я это сделал?** Для начала приведу степенной ряд, который я нашел в Яндекс.Картинках (картинка вполне рандомная, но верность ее подтвердил. Тем не менее, область определения функция от -1 до 1 включительно):
![https://disk.yandex.ru/i/nA0-JGP7sdOapw - альтернативная ссылка на моем диске.](https://studfile.net/html/2706/363/html_y1l5w7Rd0m.4yYq/img-PxkcLc.png) В общем, первый шаг - это просто аргумент х. Теперь вот так я переходил от аргумента на k-ом шаге к (k+1) шагу: пусть нынешняя степень при x равна n, тогда у нас последнее слагаемое выглядит как 1/2 * 3/4 * 5/6 * ... * (n - 2)/(n - 1) * x^n / n. Чтобы перейти к следующему слагаемому в этом ряду, то есть к 1/2 * ... * (n - 2)/(n - 1) * n/(n + 1) * x^(n+2) / (n+2) надо умножить на x^2 * n^2 / (n+1) / (n+2). Этим я и занимался каждый шаг в своем коде:

Так как вы еще не читали код, может быть, скажу: f0 хранить множитель, который не содержит x (то есть это как раз часть 1/2 * 3/4 * 5/6 * ...), а f1 как раз хранит x. При этом само слагаемое в целом хранится в f4. Я его сначала домножаю два раза на f1 (то есть умножаю на x в квадрате), потом умножаю 2 раза на f0 (он же n), а потом делю на (n+1) и на (n+2) (faddi - мною определенный макрос с очевидным функционалом).

```
count_arcsin:
	fadd.d	f2 f3 f5 # делаем предыдущую итерацию равной нынешней, чтобы потом сделать новую итерацию
	# увеличиваем степень аргумента в f4 на 2
	fmul.d	f4 f4 f1
	fmul.d  f4 f4 f1
	# пусть n = f0. Умножаем f4 на n 2 раза
	fmul.d  f4 f4 f0
	fmul.d  f4 f4 f0
	# Делим f0 на n + 1 и n + 2
	faddi (f0, t0, 1)
	fdiv.d	f4 f4 f0
	faddi (f0, t0, 1)
	fdiv.d	f4 f4 f0
	# в результате из f0 = 1/2 * 3/4 * ... * (n-2)/(n-1) * x^n / n 
	# мы получаем 1/2 * ... (n-2) / (n-1) *  n / (n+1) * x^(n+2) / (n+2) - новое слагаемое в степенном ряду
	fadd.d	f3 f3 f4 # добавляем к нынешней сумме текущее слагаемое
	fadd.d	%x f3 f5 # сразу обновляем ответ, так как все равно этот ответ будет ближе к истине, чем предыдущий
	b check_iter # осуществляем проверку на необходимость следующей итерации
```

Для проверки точности/погрешности я в коде использовал сравнение предыдущего и нынешнего результатов вычисления степенного ряда (они хранятся в f2 и f3 соответственно) с очень близким к 1 числом, в моем случае - это 1.000001.

### Хочу претендовать на 10 баллов. По критериям: ###

**4-5 баллов:** задача решена на ассемблере; ввод данных осщуествляется с клавиатуры, а вывод – на дисплей. В программе есть комментарии, не запутаетесь :-)
Также есть тестовая программа, но об этом чуть позже.

**6-7 баллов:** в программе используются макросы (они для критерия повыше) и подпрограммы. Подпрограммы используются для тестовой программы на risc-v, а также для критериев на 10 баллов. В макросах реализовано повторное использование, переменные загружаются на стек. В местах вызова функций (макросов) есть комментарии, в подпрограммах меняются только регистры a и fa, но они, по большей части, реализованы для удобства личного, но, тем не менее, они аргументы не меняют, задействуют только непостоянные регистры (типа t и ft), так что могут быть многократно использованы.

**8 баллов:** программа поддерживает многократное использование с различными наборами исходных данных. И есть программа для тестирования на Python 3, в которой вбиты тесты (запускаете в консоли приложение/IDE (я использовал JetBrains PyCharm CE), оно само выведет что за тесты и что выводит программа на RARS). Также есть тестовая программа на самом risc-v, с комментариями, пояснениями и проверкой на разницу меньше, чем 1.05.

**9 баллов:** все подпрограммы обернуты в макросы, ввод и вывод данных тоже используют макросы. Макросы поддерживают повторное использование. Есть как макросы, поддерживающие многократное использование (считывание числа double, вывод строки), так и мои собственные обертки (вшитая проверка на верность аргумента в вводе числа double, например).

**10 баллов:** все макросы находятся в отдельной библиотеке, тестовая программа и сама программа на RARS используют одни и те же модули для ввода-вывода. Есть отдельные единицы компиляции для ввода-вывода.
